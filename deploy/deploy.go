package deploy

import (
	"archive/tar"
	"errors"
	"fmt"
	"os"
	"strings"

	"github.com/ghodss/yaml"
	"github.com/kubernetes/deployment-manager/common"
	"github.com/kubernetes/deployment-manager/expandybird/expander"
	"github.com/kubernetes/deployment-manager/registry"
)

// Deployer is capable of deploying an object to a back-end.
type Deployer interface {
	// Prepare prepares the local side of a deployment.
	Prepare() error

	// Commit pushes a deployment and checks that it is completed.
	//
	// This sends the data to the given host.
	Commit(host string) error
}

// Deployment describes a deployment of a package.
type Deployment struct {
	// Name is the Deployment name. Autogenerated if empty.
	Name string
	// Filename is the filename for the base deployment.
	Filename string
	// Imports is a list of imported files.
	Imports []string
	// Properties to pass into the template.
	Properties map[string]interface{}
	// Input is a file containing templates. It may be os.Stdin.
	Input *os.File
	// Repository is the location of the templates.
	Repository string

	// The template, typically generated by the Deployment.
	Template *common.Template
}

// Prepare loads templates and checks for client-side errors.
//
// This will generate the Template based on other information.
func (d *Deployment) Prepare() error {

	tpl, err := d.resolveTemplate()
	if err != nil {
		return err
	}

	// If a deployment Name is specified, set that explicitly.
	if d.Name != "" {
		tpl.Name = d.Name
	}

	d.Template = tpl

	return nil
}

// Commit prepares the Deployment and then commits it to the remote processor.
func (d *Deployment) Commit(host string) error {
	return nil
}

// resolveTemplate resolves what kind of template is being loaded, and then returns the template.
func (d *Deployment) resolveTemplate() (*common.Template, error) {
	// If some input has been specified, read it.
	if d.Input != nil {
		// Assume this is a tar archive.
		tpl, err := expander.NewTemplateFromArchive(d.Filename, d.Input, d.Imports)
		if err == nil {
			return tpl, err
		} else if err != tar.ErrHeader {
			return nil, err
		}

		// If we get here, the file is not a tar archive.
		if _, err := os.Stdin.Seek(0, 0); err != nil {
			return nil, err
		}
		return expander.NewTemplateFromReader(d.Filename, d.Input, d.Imports)
	}

	// Non-Stdin case
	if len(d.Imports) > 0 {
		if t, err := registryType(d.Filename); err != nil {
			return expander.NewTemplateFromRootTemplate(d.Filename)
		} else {
			return buildTemplateFromType(t, d.Repository, d.Properties)
		}
	}
	return expander.NewTemplateFromFileNames(d.Filename, d.Imports)
}

// registryType is a placeholder until registry.ParseType() is merged.
func registryType(name string) (*registry.Type, error) {
	tList := strings.Split(name, ":")
	if len(tList) != 2 {
		return nil, errors.New("No version")
	}

	tt := registry.Type{Version: tList[1]}

	cList := strings.Split(tList[0], "/")

	if len(cList) == 1 {
		tt.Name = tList[0]
	} else {
		tt.Collection = cList[0]
		tt.Name = cList[1]
	}
	return &tt, nil
}

// buildTemplateFromType is a straight lift-n-shift from dm.go.
func buildTemplateFromType(t *registry.Type, reg string, props map[string]interface{}) (*common.Template, error) {
	// Name the deployment after the type name.
	name := fmt.Sprintf("%s:%s", t.Name, t.Version)
	git, err := getGitRegistry(reg)
	if err != nil {
		return nil, err
	}
	gurls, err := git.GetURLs(*t)
	if err != nil {
		return nil, err
	}

	config := common.Configuration{Resources: []*common.Resource{&common.Resource{
		Name:       name,
		Type:       gurls[0],
		Properties: props,
	}}}

	y, err := yaml.Marshal(config)
	if err != nil {
		return nil, fmt.Errorf("error: %s\ncannot create configuration for deployment: %v\n", err, config)
	}

	return &common.Template{
		Name:    name,
		Content: string(y),
		// No imports, as this is a single type from repository.
	}, nil
}

// getGitRegistry returns a registry object for a name.
func getGitRegistry(reg string) (registry.Registry, error) {
	s := strings.SplitN(reg, "/", 3)
	if len(s) < 2 {
		return nil, fmt.Errorf("invalid template registry: %s", reg)
	}

	path := ""
	if len(s) > 2 {
		path = s[3]
	}

	if s[0] == "helm" {
		return registry.NewGithubPackageRegistry(s[0], s[1], nil), nil
	} else {
		return registry.NewGithubRegistry(s[0], s[1], path, nil), nil
	}
}
