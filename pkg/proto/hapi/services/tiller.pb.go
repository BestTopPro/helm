// Code generated by protoc-gen-go.
// source: hapi/services/tiller.proto
// DO NOT EDIT!

package services

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import hapi_chart3 "github.com/deis/tiller/pkg/proto/hapi/chart"
import hapi_chart "github.com/deis/tiller/pkg/proto/hapi/chart"
import hapi_release2 "github.com/deis/tiller/pkg/proto/hapi/release"
import hapi_release "github.com/deis/tiller/pkg/proto/hapi/release"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

//
// ListReleasesRequest:
//
// 		TODO
//
type ListReleasesRequest struct {
	// The maximum number of releases to be returned
	Limit int64 `protobuf:"varint,1,opt,name=limit" json:"limit,omitempty"`
	// The zero-based offset at which the returned release list begins
	Offset int64 `protobuf:"varint,2,opt,name=offset" json:"offset,omitempty"`
}

func (m *ListReleasesRequest) Reset()                    { *m = ListReleasesRequest{} }
func (m *ListReleasesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListReleasesRequest) ProtoMessage()               {}
func (*ListReleasesRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

//
// ListReleasesResponse:
//
// 		TODO
//
type ListReleasesResponse struct {
	// The expected total number of releases to be returned
	Count int64 `protobuf:"varint,1,opt,name=count" json:"count,omitempty"`
	// The zero-based offset at which the list is positioned
	Offset int64 `protobuf:"varint,2,opt,name=offset" json:"offset,omitempty"`
	// The total number of queryable releases
	Total int64 `protobuf:"varint,3,opt,name=total" json:"total,omitempty"`
	// The resulting releases
	Releases []*hapi_release2.Release `protobuf:"bytes,4,rep,name=releases" json:"releases,omitempty"`
}

func (m *ListReleasesResponse) Reset()                    { *m = ListReleasesResponse{} }
func (m *ListReleasesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListReleasesResponse) ProtoMessage()               {}
func (*ListReleasesResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *ListReleasesResponse) GetReleases() []*hapi_release2.Release {
	if m != nil {
		return m.Releases
	}
	return nil
}

//
// GetReleaseStatusRequest:
//
// 		TODO
//
type GetReleaseStatusRequest struct {
	// The name of the release
	ReleaseName string `protobuf:"bytes,1,opt,name=release_name,json=releaseName" json:"release_name,omitempty"`
}

func (m *GetReleaseStatusRequest) Reset()                    { *m = GetReleaseStatusRequest{} }
func (m *GetReleaseStatusRequest) String() string            { return proto.CompactTextString(m) }
func (*GetReleaseStatusRequest) ProtoMessage()               {}
func (*GetReleaseStatusRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

//
// GetReleaseStatusResponse:
//
// 		TODO
//
type GetReleaseStatusResponse struct {
	// The name of the release
	ReleaseName string `protobuf:"bytes,1,opt,name=release_name,json=releaseName" json:"release_name,omitempty"`
	// The release status
	ReleaseStatus *hapi_release.Status `protobuf:"bytes,2,opt,name=release_status,json=releaseStatus" json:"release_status,omitempty"`
}

func (m *GetReleaseStatusResponse) Reset()                    { *m = GetReleaseStatusResponse{} }
func (m *GetReleaseStatusResponse) String() string            { return proto.CompactTextString(m) }
func (*GetReleaseStatusResponse) ProtoMessage()               {}
func (*GetReleaseStatusResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *GetReleaseStatusResponse) GetReleaseStatus() *hapi_release.Status {
	if m != nil {
		return m.ReleaseStatus
	}
	return nil
}

//
// GetReleaseContentRequest:
//
// 		TODO
//
type GetReleaseContentRequest struct {
	// The name of the release
	ReleaseName string `protobuf:"bytes,1,opt,name=release_name,json=releaseName" json:"release_name,omitempty"`
}

func (m *GetReleaseContentRequest) Reset()                    { *m = GetReleaseContentRequest{} }
func (m *GetReleaseContentRequest) String() string            { return proto.CompactTextString(m) }
func (*GetReleaseContentRequest) ProtoMessage()               {}
func (*GetReleaseContentRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

//
// GetReleaseContentResponse:
//
// 		TODO
//
type GetReleaseContentResponse struct {
	// The release content
	Release *hapi_release2.Release `protobuf:"bytes,1,opt,name=release" json:"release,omitempty"`
}

func (m *GetReleaseContentResponse) Reset()                    { *m = GetReleaseContentResponse{} }
func (m *GetReleaseContentResponse) String() string            { return proto.CompactTextString(m) }
func (*GetReleaseContentResponse) ProtoMessage()               {}
func (*GetReleaseContentResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{5} }

func (m *GetReleaseContentResponse) GetRelease() *hapi_release2.Release {
	if m != nil {
		return m.Release
	}
	return nil
}

//
// UpdateReleaseRequest:
//
// 		TODO
//
type UpdateReleaseRequest struct {
}

func (m *UpdateReleaseRequest) Reset()                    { *m = UpdateReleaseRequest{} }
func (m *UpdateReleaseRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateReleaseRequest) ProtoMessage()               {}
func (*UpdateReleaseRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{6} }

//
// UpdateReleaseResponse:
//
// 		TODO
//
type UpdateReleaseResponse struct {
}

func (m *UpdateReleaseResponse) Reset()                    { *m = UpdateReleaseResponse{} }
func (m *UpdateReleaseResponse) String() string            { return proto.CompactTextString(m) }
func (*UpdateReleaseResponse) ProtoMessage()               {}
func (*UpdateReleaseResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{7} }

//
// InstallReleaseRequest:
//
// 		TODO
//
type InstallReleaseRequest struct {
	// Chart is the protobuf representation of a chart.
	Chart *hapi_chart3.Chart `protobuf:"bytes,1,opt,name=chart" json:"chart,omitempty"`
	// Values is a string containing (unparsed) TOML values.
	Values *hapi_chart.Config `protobuf:"bytes,2,opt,name=values" json:"values,omitempty"`
}

func (m *InstallReleaseRequest) Reset()                    { *m = InstallReleaseRequest{} }
func (m *InstallReleaseRequest) String() string            { return proto.CompactTextString(m) }
func (*InstallReleaseRequest) ProtoMessage()               {}
func (*InstallReleaseRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{8} }

func (m *InstallReleaseRequest) GetChart() *hapi_chart3.Chart {
	if m != nil {
		return m.Chart
	}
	return nil
}

func (m *InstallReleaseRequest) GetValues() *hapi_chart.Config {
	if m != nil {
		return m.Values
	}
	return nil
}

//
// InstallReleaseResponse:
//
// 		TODO
//
type InstallReleaseResponse struct {
	Release *hapi_release2.Release `protobuf:"bytes,1,opt,name=release" json:"release,omitempty"`
}

func (m *InstallReleaseResponse) Reset()                    { *m = InstallReleaseResponse{} }
func (m *InstallReleaseResponse) String() string            { return proto.CompactTextString(m) }
func (*InstallReleaseResponse) ProtoMessage()               {}
func (*InstallReleaseResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{9} }

func (m *InstallReleaseResponse) GetRelease() *hapi_release2.Release {
	if m != nil {
		return m.Release
	}
	return nil
}

//
// UninstallReleaseRequest:
//
// 		TODO
//
type UninstallReleaseRequest struct {
}

func (m *UninstallReleaseRequest) Reset()                    { *m = UninstallReleaseRequest{} }
func (m *UninstallReleaseRequest) String() string            { return proto.CompactTextString(m) }
func (*UninstallReleaseRequest) ProtoMessage()               {}
func (*UninstallReleaseRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{10} }

//
// UninstallReleaseResponse:
//
// 		TODO
//
type UninstallReleaseResponse struct {
}

func (m *UninstallReleaseResponse) Reset()                    { *m = UninstallReleaseResponse{} }
func (m *UninstallReleaseResponse) String() string            { return proto.CompactTextString(m) }
func (*UninstallReleaseResponse) ProtoMessage()               {}
func (*UninstallReleaseResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{11} }

func init() {
	proto.RegisterType((*ListReleasesRequest)(nil), "hapi.services.tiller.ListReleasesRequest")
	proto.RegisterType((*ListReleasesResponse)(nil), "hapi.services.tiller.ListReleasesResponse")
	proto.RegisterType((*GetReleaseStatusRequest)(nil), "hapi.services.tiller.GetReleaseStatusRequest")
	proto.RegisterType((*GetReleaseStatusResponse)(nil), "hapi.services.tiller.GetReleaseStatusResponse")
	proto.RegisterType((*GetReleaseContentRequest)(nil), "hapi.services.tiller.GetReleaseContentRequest")
	proto.RegisterType((*GetReleaseContentResponse)(nil), "hapi.services.tiller.GetReleaseContentResponse")
	proto.RegisterType((*UpdateReleaseRequest)(nil), "hapi.services.tiller.UpdateReleaseRequest")
	proto.RegisterType((*UpdateReleaseResponse)(nil), "hapi.services.tiller.UpdateReleaseResponse")
	proto.RegisterType((*InstallReleaseRequest)(nil), "hapi.services.tiller.InstallReleaseRequest")
	proto.RegisterType((*InstallReleaseResponse)(nil), "hapi.services.tiller.InstallReleaseResponse")
	proto.RegisterType((*UninstallReleaseRequest)(nil), "hapi.services.tiller.UninstallReleaseRequest")
	proto.RegisterType((*UninstallReleaseResponse)(nil), "hapi.services.tiller.UninstallReleaseResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion1

// Client API for ReleaseService service

type ReleaseServiceClient interface {
	//
	// Retrieve release history. TODO: Allow filtering the set of releases by
	// release status. By default, ListAllReleases returns the releases who
	// current status is "Active".
	//
	ListReleases(ctx context.Context, in *ListReleasesRequest, opts ...grpc.CallOption) (ReleaseService_ListReleasesClient, error)
	//
	// Retrieve status information for the specified release.
	//
	GetReleaseStatus(ctx context.Context, in *GetReleaseStatusRequest, opts ...grpc.CallOption) (*GetReleaseStatusResponse, error)
	//
	// Retrieve the release content (chart + value) for the specifed release.
	//
	GetReleaseContent(ctx context.Context, in *GetReleaseContentRequest, opts ...grpc.CallOption) (*GetReleaseContentResponse, error)
	//
	// Update release content.
	//
	UpdateRelease(ctx context.Context, in *UpdateReleaseRequest, opts ...grpc.CallOption) (*UpdateReleaseResponse, error)
	//
	// Request release install.
	//
	InstallRelease(ctx context.Context, in *InstallReleaseRequest, opts ...grpc.CallOption) (*InstallReleaseResponse, error)
	//
	// Request release deletion.
	//
	UninstallRelease(ctx context.Context, in *UninstallReleaseRequest, opts ...grpc.CallOption) (*UninstallReleaseResponse, error)
}

type releaseServiceClient struct {
	cc *grpc.ClientConn
}

func NewReleaseServiceClient(cc *grpc.ClientConn) ReleaseServiceClient {
	return &releaseServiceClient{cc}
}

func (c *releaseServiceClient) ListReleases(ctx context.Context, in *ListReleasesRequest, opts ...grpc.CallOption) (ReleaseService_ListReleasesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ReleaseService_serviceDesc.Streams[0], c.cc, "/hapi.services.tiller.ReleaseService/ListReleases", opts...)
	if err != nil {
		return nil, err
	}
	x := &releaseServiceListReleasesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ReleaseService_ListReleasesClient interface {
	Recv() (*ListReleasesResponse, error)
	grpc.ClientStream
}

type releaseServiceListReleasesClient struct {
	grpc.ClientStream
}

func (x *releaseServiceListReleasesClient) Recv() (*ListReleasesResponse, error) {
	m := new(ListReleasesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *releaseServiceClient) GetReleaseStatus(ctx context.Context, in *GetReleaseStatusRequest, opts ...grpc.CallOption) (*GetReleaseStatusResponse, error) {
	out := new(GetReleaseStatusResponse)
	err := grpc.Invoke(ctx, "/hapi.services.tiller.ReleaseService/GetReleaseStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseServiceClient) GetReleaseContent(ctx context.Context, in *GetReleaseContentRequest, opts ...grpc.CallOption) (*GetReleaseContentResponse, error) {
	out := new(GetReleaseContentResponse)
	err := grpc.Invoke(ctx, "/hapi.services.tiller.ReleaseService/GetReleaseContent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseServiceClient) UpdateRelease(ctx context.Context, in *UpdateReleaseRequest, opts ...grpc.CallOption) (*UpdateReleaseResponse, error) {
	out := new(UpdateReleaseResponse)
	err := grpc.Invoke(ctx, "/hapi.services.tiller.ReleaseService/UpdateRelease", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseServiceClient) InstallRelease(ctx context.Context, in *InstallReleaseRequest, opts ...grpc.CallOption) (*InstallReleaseResponse, error) {
	out := new(InstallReleaseResponse)
	err := grpc.Invoke(ctx, "/hapi.services.tiller.ReleaseService/InstallRelease", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseServiceClient) UninstallRelease(ctx context.Context, in *UninstallReleaseRequest, opts ...grpc.CallOption) (*UninstallReleaseResponse, error) {
	out := new(UninstallReleaseResponse)
	err := grpc.Invoke(ctx, "/hapi.services.tiller.ReleaseService/UninstallRelease", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ReleaseService service

type ReleaseServiceServer interface {
	//
	// Retrieve release history. TODO: Allow filtering the set of releases by
	// release status. By default, ListAllReleases returns the releases who
	// current status is "Active".
	//
	ListReleases(*ListReleasesRequest, ReleaseService_ListReleasesServer) error
	//
	// Retrieve status information for the specified release.
	//
	GetReleaseStatus(context.Context, *GetReleaseStatusRequest) (*GetReleaseStatusResponse, error)
	//
	// Retrieve the release content (chart + value) for the specifed release.
	//
	GetReleaseContent(context.Context, *GetReleaseContentRequest) (*GetReleaseContentResponse, error)
	//
	// Update release content.
	//
	UpdateRelease(context.Context, *UpdateReleaseRequest) (*UpdateReleaseResponse, error)
	//
	// Request release install.
	//
	InstallRelease(context.Context, *InstallReleaseRequest) (*InstallReleaseResponse, error)
	//
	// Request release deletion.
	//
	UninstallRelease(context.Context, *UninstallReleaseRequest) (*UninstallReleaseResponse, error)
}

func RegisterReleaseServiceServer(s *grpc.Server, srv ReleaseServiceServer) {
	s.RegisterService(&_ReleaseService_serviceDesc, srv)
}

func _ReleaseService_ListReleases_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListReleasesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ReleaseServiceServer).ListReleases(m, &releaseServiceListReleasesServer{stream})
}

type ReleaseService_ListReleasesServer interface {
	Send(*ListReleasesResponse) error
	grpc.ServerStream
}

type releaseServiceListReleasesServer struct {
	grpc.ServerStream
}

func (x *releaseServiceListReleasesServer) Send(m *ListReleasesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ReleaseService_GetReleaseStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(GetReleaseStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReleaseServiceServer).GetReleaseStatus(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ReleaseService_GetReleaseContent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(GetReleaseContentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReleaseServiceServer).GetReleaseContent(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ReleaseService_UpdateRelease_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UpdateReleaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReleaseServiceServer).UpdateRelease(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ReleaseService_InstallRelease_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(InstallReleaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReleaseServiceServer).InstallRelease(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ReleaseService_UninstallRelease_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UninstallReleaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReleaseServiceServer).UninstallRelease(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _ReleaseService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hapi.services.tiller.ReleaseService",
	HandlerType: (*ReleaseServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetReleaseStatus",
			Handler:    _ReleaseService_GetReleaseStatus_Handler,
		},
		{
			MethodName: "GetReleaseContent",
			Handler:    _ReleaseService_GetReleaseContent_Handler,
		},
		{
			MethodName: "UpdateRelease",
			Handler:    _ReleaseService_UpdateRelease_Handler,
		},
		{
			MethodName: "InstallRelease",
			Handler:    _ReleaseService_InstallRelease_Handler,
		},
		{
			MethodName: "UninstallRelease",
			Handler:    _ReleaseService_UninstallRelease_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListReleases",
			Handler:       _ReleaseService_ListReleases_Handler,
			ServerStreams: true,
		},
	},
}

var fileDescriptor1 = []byte{
	// 529 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x9c, 0x55, 0x4d, 0x73, 0xd3, 0x30,
	0x10, 0x6d, 0x08, 0x0d, 0x65, 0xd3, 0x66, 0xa8, 0x70, 0x12, 0x47, 0xa7, 0xa2, 0x0b, 0xa5, 0x80,
	0x03, 0xe1, 0x08, 0x5c, 0xc8, 0x81, 0xe9, 0x4c, 0x87, 0x83, 0x99, 0x5e, 0xb8, 0x30, 0x26, 0x28,
	0x54, 0x8c, 0x62, 0x07, 0x4b, 0xc9, 0x81, 0xff, 0xc0, 0xff, 0xe1, 0xe7, 0x61, 0xeb, 0xc3, 0x13,
	0x39, 0xd6, 0xd4, 0xf4, 0xe2, 0x8c, 0xf4, 0xde, 0xee, 0xdb, 0x5d, 0xbd, 0x9d, 0x00, 0xbe, 0x49,
	0xd6, 0x6c, 0x2a, 0x68, 0xbe, 0x65, 0x0b, 0x2a, 0xa6, 0x92, 0x71, 0x4e, 0xf3, 0x68, 0x9d, 0x67,
	0x32, 0x43, 0x41, 0x89, 0x45, 0x16, 0x8b, 0x34, 0x86, 0x47, 0x2a, 0x62, 0x71, 0x93, 0xe4, 0x52,
	0x7f, 0x35, 0x1b, 0x8f, 0x77, 0xef, 0xb3, 0x74, 0xc9, 0x7e, 0x18, 0x40, 0x4b, 0xe4, 0x94, 0xd3,
	0x44, 0x50, 0xfb, 0x6b, 0xb0, 0x89, 0x83, 0x09, 0x99, 0xc8, 0x8d, 0xd0, 0x10, 0x99, 0xc3, 0xe3,
	0x2b, 0x26, 0x64, 0xac, 0x31, 0x11, 0xd3, 0x5f, 0x1b, 0x2a, 0x24, 0x0a, 0xe0, 0x90, 0xb3, 0x15,
	0x93, 0x61, 0xe7, 0xac, 0x73, 0xde, 0x8d, 0xf5, 0x01, 0x8d, 0xa0, 0x97, 0x2d, 0x97, 0x82, 0xca,
	0xf0, 0x9e, 0xba, 0x36, 0x27, 0xf2, 0xa7, 0x03, 0x81, 0x9b, 0x45, 0xac, 0xb3, 0x54, 0xd0, 0x32,
	0xcd, 0x22, 0xdb, 0xa4, 0x55, 0x1a, 0x75, 0xf0, 0xa5, 0x29, 0xd9, 0x32, 0x93, 0x09, 0x0f, 0xbb,
	0x9a, 0xad, 0x0e, 0xe8, 0x35, 0x1c, 0x99, 0xca, 0x45, 0x78, 0xff, 0xac, 0x7b, 0xde, 0x9f, 0x0d,
	0x23, 0x35, 0x32, 0xdb, 0xa3, 0x51, 0x8d, 0x2b, 0x1a, 0x79, 0x07, 0xe3, 0x8f, 0xd4, 0x56, 0xf3,
	0x59, 0xb5, 0x6b, 0x1b, 0x7b, 0x02, 0xc7, 0x86, 0xf6, 0x35, 0x4d, 0x56, 0x54, 0x15, 0xf6, 0x30,
	0xee, 0x9b, 0xbb, 0x4f, 0xc5, 0x15, 0xf9, 0x0d, 0xe1, 0x7e, 0xb4, 0x69, 0xe8, 0xf6, 0x70, 0xf4,
	0x16, 0x06, 0x96, 0xa2, 0x27, 0xad, 0xba, 0xec, 0xcf, 0x02, 0xb7, 0x6a, 0x93, 0xf8, 0x24, 0xdf,
	0xd5, 0x21, 0xef, 0x77, 0xb5, 0xe7, 0x59, 0x2a, 0x69, 0x2a, 0xff, 0xa3, 0xf4, 0x2b, 0x98, 0x34,
	0x84, 0x9b, 0xda, 0xa7, 0xf0, 0xc0, 0x70, 0x55, 0xa8, 0x77, 0x8e, 0x96, 0x45, 0x46, 0x10, 0x5c,
	0xaf, 0xbf, 0x27, 0x92, 0x5a, 0x44, 0x17, 0x42, 0xc6, 0x30, 0xac, 0xdd, 0x6b, 0x05, 0xc2, 0x61,
	0x78, 0x99, 0x16, 0x4d, 0x73, 0xee, 0x46, 0xa0, 0xa7, 0x85, 0x0f, 0x4a, 0xcb, 0x1a, 0xe1, 0x53,
	0x2d, 0xac, 0x7d, 0x3d, 0x2f, 0xbf, 0xb1, 0xc6, 0xd1, 0x05, 0xf4, 0xb6, 0x09, 0x2f, 0x62, 0xcc,
	0xd0, 0x90, 0xc3, 0x54, 0x7e, 0x8f, 0x0d, 0x83, 0x5c, 0xc2, 0xa8, 0xae, 0x76, 0xd7, 0x4e, 0x27,
	0x30, 0xbe, 0x4e, 0x59, 0x53, 0xe9, 0x04, 0x43, 0xb8, 0x0f, 0x69, 0x9d, 0xd9, 0xdf, 0x43, 0x18,
	0x58, 0x9f, 0xe8, 0xfd, 0x45, 0x0c, 0x8e, 0x77, 0x37, 0x01, 0x3d, 0x8b, 0x9a, 0xd6, 0x3b, 0x6a,
	0xd8, 0x39, 0x7c, 0xd1, 0x86, 0x6a, 0x26, 0x7d, 0xf0, 0xaa, 0x83, 0x04, 0x3c, 0xaa, 0xfb, 0x14,
	0xbd, 0x6c, 0xce, 0xe1, 0xd9, 0x06, 0x1c, 0xb5, 0xa5, 0x5b, 0x59, 0xb4, 0x85, 0xd3, 0x3d, 0x87,
	0xa1, 0x5b, 0xd3, 0xb8, 0x4e, 0xc6, 0xd3, 0xd6, 0xfc, 0x4a, 0xf7, 0x27, 0x9c, 0x38, 0x9e, 0x43,
	0x9e, 0x69, 0x35, 0x19, 0x16, 0x3f, 0x6f, 0xc5, 0xad, 0xb4, 0x56, 0x30, 0x70, 0x8d, 0x85, 0x3c,
	0x09, 0x1a, 0xcd, 0x8e, 0x5f, 0xb4, 0x23, 0x57, 0x72, 0xc5, 0x3b, 0xd6, 0x1d, 0xe6, 0x7b, 0x47,
	0x8f, 0x49, 0x7d, 0xef, 0xe8, 0x33, 0x2e, 0x39, 0xf8, 0x00, 0x5f, 0x8e, 0x2c, 0xfb, 0x5b, 0x4f,
	0xfd, 0x15, 0xbc, 0xf9, 0x17, 0x00, 0x00, 0xff, 0xff, 0x75, 0xe1, 0x2e, 0x4f, 0xa6, 0x06, 0x00,
	0x00,
}
